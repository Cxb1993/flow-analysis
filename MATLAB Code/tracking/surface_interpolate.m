function  [zi, varargout] = surface_interpolate(x,y,z,xi,yi,varargin)
%zi = surface_interpolate(x,y,z,xi,yi,num)
%
% This function takes randomly scattered points and returns interpolated
% values at a predefined grid of points. For any grid point, the code finds
% the nearest num points in the original data set, and interpolates the
% values at these points to give the value at the grid point. Interpolation
% is quadratic, fitting to a form ax^2+bxy+cy^2+dx+ey+f=z.
%
%REQUIRED INPUTS: 
%x and y are column vectors containing coordinates of
%unevenly spaced points that are going to be interpolated between. 
%
%z is a column vector of values associated with those points that is to be
% interpolated. It must be the same length as x and y.
%
%xi and yi are matrices of regularly spaced x and y coordinates such as
%would be generated by the function 'meshgrid'. These are the points that
%the current function will interpolate values onto. 
%
%OPTIONAL INPUTS
%num = number of points to use for the interpolation. Default is 7. to fit a
%surface is 6. If you enter a number less than 6, it will use 7. If you use
%6 then the fit surface will pass through all six points and be strongly
%influenced by the presence of one aberrant vector. The more points you use
%the less sensitive the solution will be to noise and the smoother the
%final output.
%
%OUTPUTS: 
%zi is a matrix the same size as xi and yi containing the interpolated
%values for each point.
%
%OPTIONAL OUTPUT:
%If the user specifies the function will return a matrix giving
%the maximum distance that was used for the interpolation at each grid
%point. If the grid point was outside the limits of the ramdomly sampled
%data set it will return NaN for this point.
%
%MODIFICATION HISTORY:
% Callen Hyland, August 2011
% Tweaked and additional commenting by Rob Style, January 2014
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

num = 7;
if nargin > 5 && varargin{1,1}>6
    num = varargin{1,1};
end

[X Y] = size(xi);
zi = zeros(X,Y); % Make grid of zeros to put interpolated z data in
dist_mat = zeros(X,Y); % Will store the maximum distance used for interpolation at a grid point

%limits of randomly sampled data set
min_x = min(x);
min_y = min(y);
max_x = max(x);
max_y = max(y);


for i = 1:X
    for j = 1:Y
        closest_pts = [x,y,z, zeros(length(x),1)];
        % Get current grid position
        pos = [xi(i,j) yi(i,j)];
        
        % If the grid position is outside of the limits of the original data set, set to NaN
        if pos(1)<min_x || pos(2)<min_y || pos(1)>max_x || pos(2)>max_y
            zi(i,j) = NaN; dist_mat(i,j) = NaN;
        else
            % Find distance of each data point to the current grid point
            closest_pts(:,4)= sqrt((closest_pts(:,1)-pos(1)).^2 + (closest_pts(:,2)-pos(2)).^2);
            % Sort by ascending distance
            closest_pts = sortrows(closest_pts,4);
            % Find closest 'num' points
            
            % Use surface fitting to find interpolated displacement at 'pos'
            Xf = closest_pts(1:num,1); Yf = closest_pts(1:num,2); Uf = closest_pts(1:num,3);
            P = zeros(num,6);
            P(:,1) = 1;
            P(:,2) = Xf;
            P(:,3) = Yf;
            P(:,4) = Xf.^2;
            P(:,5) = Yf.^2;
            P(:,6) = Xf.*Yf;
            %This is a standard method of finding the least squares
            %solution for a system of equation (see 'Linear Algebra With
            %Applications' by Otto Bretscher)
            a = pinv(P'*P)*P'*Uf; 
            interp = a(1) + a(2)*pos(1) + a(3)*pos(2) + a(4)*(pos(1)^2)+...
                a(5)*(pos(2)^2) + a(6)*pos(1)*pos(2);
            
            zi(i,j) = interp;
            dist_mat(i,j) = closest_pts(num,4);
        end

    end
end

if nargout>1
    varargout{1,1} = dist_mat;
end
 
